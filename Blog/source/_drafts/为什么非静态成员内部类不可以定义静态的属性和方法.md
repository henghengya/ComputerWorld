---
title: 为什么非静态成员内部类不可以定义静态的属性和方法
date: 2020-01-26 19:40:29
tags: JAVA
categories: 
	- 1/0世界
	- JAVA
---
我们可以在非静态内部类中定义非静态属性和方法，但不可以定义static修饰的属性和方法。

首先，静态变量、静态方法是在类加载时放入虚拟机堆内存的方法区中，它们是不依赖于对象的，比对象更早生成。而想要访问非静态成员内部类，必须先要有实例化的外部类对象，然后通过外部类才能访问内部类。

非静态成员内部类可以看成外部类的一个成员变量，只要是成员变量，各个对象是不相关联的，而内部类中static修饰的静态属性和方法却是属于类的全局变量，不属于对象，破坏了这一逻辑，使得在Java的语义层面产生分歧，所以不会被允许。

但是静态成员内部类则是可以定义的。这是因为静态内部类可以看做外部类的静态成员，可以通过：外部类名.静态内部类名.静态变量/方法 来访问内部类成员，

在非静态成员内部类中，若定义一个静态对象常量：“static final Integer d = 1”，编译不通过；而基本数据类型常量“static final int c = 0”则可以编译通过。因为？？？？

此事涉及到常量的两种类型：编译期常量和运行时常量
	编译期常量：
		static final int A= 1024；
		编译时A的数值已经可以确定，不需要运行，类型必须是 基本类型
	运行时常量：
		static final int LENGTH = "test".length();
		LENGTH的值必须通过运行以后才能得到
而根据JVM规范，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）时，需要对类初始化。即编译期常量不依赖类，不会引起类的初始化；而运行时常量依赖类，会引起类的初始化。

而这里，类的初始化也就牵扯到了一个问题，非静态成员内部类的初始化必须通过外部类的实例进行，而常量是独立于对象存在于类层次，又有了语义上的分歧。
	
	
主要参考：
	- https://my.oschina.net/u/1027043/blog/1823113
	- https://blog.csdn.net/qq_34802416/article/details/83548369
	- https://www.cnblogs.com/cc-umf-lm/p/10621978.html
